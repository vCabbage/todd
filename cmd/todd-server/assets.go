/*
    Asset management for ToDD server

	Copyright 2016 Matt Oswalt. Use or modification of this
	source code is governed by the license provided here:
	https://github.com/toddproject/todd/blob/master/LICENSE
*/

package main

import (
	"crypto/sha256"
	"encoding/hex"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	log "github.com/Sirupsen/logrus"

	"github.com/toddproject/todd/assets"
	"github.com/toddproject/todd/config"
	"github.com/toddproject/todd/hostresources"
)

// assetConfig is responsible for deriving embedded assets like collector files and testlets from the golang source generated by go-bindata
// These will be written to the appropriate directories, a hash (SHA256) will be generated, and these files will be served via HTTP
// This function is typically run on the ToDD server.
type assetConfig struct {
	sync.RWMutex
	dir      string
	port     string
	assetMap map[string]map[string]string
}

// newAssetConfig configures and returns an assetConfig. It also starts a
// goroutine that periodically updates the assetMap and a seperate goroutine
// providing HTTP access to the assets.
func newAssetConfig(cfg config.Config) *assetConfig {
	// Derive directory for assets on server
	a := &assetConfig{
		// Derive directory for assets on server
		dir:  filepath.Join(cfg.LocalResources.OptDir, "assets"),
		port: cfg.Assets.Port,
	}

	// Periodically generate a new asset map (with mutex for safety)
	go func() {
		for {
			a.update()
			time.Sleep(5 * time.Second)
		}
	}()

	// Begin serving files to agents
	go a.serve() // TODO(moswalt): Handle error

	return a
}

// assets returns the current map of assets
func (a *assetConfig) Assets() map[string]map[string]string {
	a.RLock()
	defer a.RUnlock()
	return a.assetMap
}

// update reloads the map of assets from disk
func (a *assetConfig) update() {
	// Initialize asset map
	assetMap := map[string]map[string]string{
		"factcollectors": hashAssets("facts/collectors"),
		"testlets":       hashAssets("testing/bashtestlets"),
	}

	// Add filesystem collectors
	fcHashes, err := hashFiles(filepath.Join(a.dir, "factcollectors"))
	if err != nil {
		panic(err)
	}
	for name, hash := range fcHashes {
		assetMap["factcollectors"][name] = hash
	}

	// Add filesystem testlets
	testletsHashes, err := hashFiles(filepath.Join(a.dir, "testlets"))
	if err != nil {
		panic(err)
	}
	for name, hash := range testletsHashes {
		assetMap["testlets"][name] = hash
	}

	// Lock just long enough to swap the maps
	a.Lock()
	a.assetMap = assetMap
	a.Unlock()

	log.Debug("Loaded assets: ", assetMap)
}

// serve serves assets from disk and embedded via HTTP
func (a *assetConfig) serve() error {
	return http.ListenAndServe(":"+a.port, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// check filesystem first
		path := filepath.Join(a.dir, r.URL.Path)
		if _, err := os.Stat(path); err == nil {
			http.ServeFile(w, r, path)
			return
		}

		// If file not on fs, try assets
		path = strings.Replace(r.URL.Path, "/factcollectors", "facts/collectors", 1)
		path = strings.Replace(path, "/testlets", "testing/bashtestlets", 1)

		asset, err := assets.Asset(path)
		if err != nil {
			http.NotFound(w, r)
		}

		w.Write(asset)
	}))
}

// hashAssets returns a mapping of asset filenames to their SHA256 hash.
//
// dir is the path to the files in the assets package.
func hashAssets(dir string) map[string]string {
	names, _ := assets.AssetDir(dir)
	hashes := make(map[string]string, len(names))

	for _, name := range names {
		asset, _ := assets.Asset(dir + "/" + name)
		hasher := sha256.New()
		hasher.Write(asset)

		hashes[name] = hex.EncodeToString(hasher.Sum(nil))
	}

	return hashes
}

// hashFiles returns a mapping of filenames to their SHA256 hash.
//
// dir is the path to the files on the filesystem.
func hashFiles(dir string) (map[string]string, error) {
	finfos, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	hashes := make(map[string]string, len(finfos))
	for _, finfo := range finfos {
		name := finfo.Name()
		hashes[name] = hostresources.GetFileSHA256(filepath.Join(dir, name))
	}

	return hashes, nil
}
