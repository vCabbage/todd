/*
    Asset management for ToDD server

	Copyright 2016 Matt Oswalt. Use or modification of this
	source code is governed by the license provided here:
	https://github.com/toddproject/todd/blob/master/LICENSE
*/

package main

import (
	"crypto/sha256"
	"encoding/hex"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	log "github.com/Sirupsen/logrus"

	"github.com/toddproject/todd/assets"
	"github.com/toddproject/todd/config"
	"github.com/toddproject/todd/hostresources"
)

// serveAssets is responsible for deriving embedded assets like collector files and testlets from the golang source generated by go-bindata
// These will be written to the appropriate directories, a hash (SHA256) will be generated, and these files will be served via HTTP
// This function is typically run on the ToDD server.
func serveAssets(cfg config.Config) (*map[string]map[string]string, *sync.Mutex, error) {

	// Derive directory for assets on server
	assetDir := filepath.Join(cfg.LocalResources.OptDir, "assets")

	var assetMap = map[string]map[string]string{
		"factcollectors": hashAssets("facts/collectors"),
		"testlets":       hashAssets("testing/bashtestlets"),
	}

	// Initialize mutex for locking asset map
	var mu sync.Mutex

	// Periodically generate a new asset map (with mutex for safety)
	go func() {
		for {

			mu.Lock()

			// Reset asset map to contain only embedded assets
			assetMap = map[string]map[string]string{
				"factcollectors": hashAssets("facts/collectors"),
				"testlets":       hashAssets("testing/bashtestlets"),
			}

			// Add filesystem collectors
			fcHashes, err := hashFiles(filepath.Join(assetDir, "factcollectors"))
			if err != nil {
				panic(err)
			}
			for name, hash := range fcHashes {
				assetMap["factcollectors"][name] = hash
			}

			// Add filesystem testlets
			testletsHashes, err := hashFiles(filepath.Join(assetDir, "testlets"))
			if err != nil {
				panic(err)
			}
			for name, hash := range testletsHashes {
				assetMap["testlets"][name] = hash
			}

			mu.Unlock()
			log.Debug("Loaded assets: ", assetMap)

			time.Sleep(5 * time.Second)
		}
	}()

	// Begin serving files to agents
	// TODO(moswalt): Handle error
	go http.ListenAndServe(":"+cfg.Assets.Port, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// check filesystem first
		path := filepath.Join(assetDir, r.URL.Path)
		if _, err := os.Stat(path); err == nil {
			http.ServeFile(w, r, path)
			return
		}

		// If file not on fs, try assets
		path = strings.Replace(r.URL.Path, "/factcollectors", "facts/collectors", 1)
		path = strings.Replace(path, "/testlets", "testing/bashtestlets", 1)

		asset, err := assets.Asset(path)
		if err != nil {
			http.NotFound(w, r)
		}

		w.Write(asset)
	}))

	return &assetMap, &mu, nil
}

// hashAssets returns a mapping of asset filenames to their SHA256 hash.
//
// dir is the path to the files in the assets package.
func hashAssets(dir string) map[string]string {
	names, _ := assets.AssetDir(dir)
	hashes := make(map[string]string, len(names))

	for _, name := range names {
		asset, _ := assets.Asset(dir + "/" + name)
		hasher := sha256.New()
		hasher.Write(asset)

		hashes[name] = hex.EncodeToString(hasher.Sum(nil))
	}

	return hashes
}

// hashFiles returns a mapping of filenames to their SHA256 hash.
//
// dir is the path to the files on the filesystem.
func hashFiles(dir string) (map[string]string, error) {
	finfos, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	hashes := make(map[string]string, len(finfos))
	for _, finfo := range finfos {
		name := finfo.Name()
		hashes[name] = hostresources.GetFileSHA256(filepath.Join(dir, name))
	}

	return hashes, nil
}
